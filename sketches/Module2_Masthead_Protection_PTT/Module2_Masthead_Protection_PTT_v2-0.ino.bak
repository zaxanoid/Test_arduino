// -----------------------------------------------------------------------------
// Module 2: Masthead Protection + PTT (Arduino Nano/Teensy + MCP2515)
// -----------------------------------------------------------------------------
// Defaults:
//   - 1x DHT11 (temp + humidity)   [or DHT12 via I2C]
//   - 1x DS18B20 (temp)            [optionally 2x DS18B20]
//   - Telemetry is suppressed while PTT is ON (RF protection), configurable by compile-time flag
//
// CAN protocol: rscp_can_protocol.h (v1.5)
//   - RSCP_ID_PTT_CMD / RSCP_ID_PTT_ACK
//   - RSCP_ID_HEARTBEAT (suppressed while PTT is ON)
//   - RSCP_ID_RF_TELEM
//   - RSCP_ID_TEMP_REPORT (1 or 2 temps, labeled sensorId 1/2)
//   - RSCP_ID_HUM_REPORT (humidity + DHT temp)
//
// NOTE: MCP2515 oscillator:
//   Set MCP_8MHZ vs MCP_16MHZ to match your CAN module crystal.
// -----------------------------------------------------------------------------

#include <SPI.h>
#include <mcp2515.h>
#include <EEPROM.h>
#include <Arduino.h>

#include "rscp_can_protocol.h"

// ------------------------- Sensor selection (compile-time)
#define USE_DHT11   1
#define USE_DHT12   0     // set 1 to use DHT12 (I2C) instead of DHT11
#define DS18_COUNT  1     // set to 1 or 2

#if (USE_DHT11 + USE_DHT12) != 1
  #error "Select exactly one: USE_DHT11=1 or USE_DHT12=1"
#endif
#if (DS18_COUNT < 1) || (DS18_COUNT > 2)
  #error "DS18_COUNT must be 1 or 2"
#endif

// ------------------------- Pins
static const uint8_t PIN_LED         = 4;

static const uint8_t PIN_DHT         = 8;  // DHT11 data pin (if USE_DHT11)

static const uint8_t PIN_DS18_1      = 7;  // DS18B20 #1 (1-Wire)
static const uint8_t PIN_DS18_2      = 6;  // DS18B20 #2 (optional, if DS18_COUNT==2)

static const uint8_t PIN_PTT_OUT     = 3;  // masthead PTT output (to relay/opto)
static const uint8_t PIN_PTT_SENSE   = 2;  // sense line to confirm PTT switched (optional)
static const bool    PTT_SENSE_ENABLE = true;
static const bool    PTT_SENSE_ACTIVE_LOW = true;

static const uint8_t PIN_CAN_CS      = 10;

// Analog
static const uint8_t PIN_VBAT        = A1;
static const uint8_t PIN_FWD         = A2;
static const uint8_t PIN_REV         = A3;

// OPTIONAL: suppress env sensor reads/telemetry while PTT is ON (RF protection)
static const bool SUPPRESS_ENV_WHEN_PTT_ON = true;

// ------------------------- DHT
#if USE_DHT11
  #include <DHT.h>
  static const uint8_t DHTTYPE = DHT11;
  DHT dht(PIN_DHT, DHTTYPE);
#endif

#if USE_DHT12
  #include <Wire.h>
  static const uint8_t DHT12_ADDR = 0x5C; // common DHT12 I2C address
#endif

// ------------------------- DS18B20
#include <OneWire.h>
#include <DallasTemperature.h>

static OneWire ow1(PIN_DS18_1);
static DallasTemperature ds18_1(&ow1);

#if DS18_COUNT == 2
static OneWire ow2(PIN_DS18_2);
static DallasTemperature ds18_2(&ow2);
#endif

// ------------------------- CAN
MCP2515 mcp(PIN_CAN_CS);
struct can_frame rx;

// ------------------------- Settings in EEPROM
struct MastSettings {
  uint32_t magic;
  uint32_t stopPttErrMask; // RSCP_ERR_* bitmask
  uint32_t pttMaxMs;

  // Threshold placeholders (calibrate later)
  uint32_t vbat_low_raw;
  uint32_t vswr1_high_raw;
  uint32_t vswr2_high_raw;
  uint32_t temp1_high_x10;
  uint32_t temp2_high_x10;
  uint32_t hum_high_pct;
};

static const uint32_t MAST_MAGIC = 0x4D415354; // "MAST"
MastSettings cfg;

// ------------------------- Runtime state
static bool     ptt_requested = false;
static uint8_t  last_ptt_seq = 0;
static uint32_t ptt_on_ms = 0;
static uint32_t ptt_cmd_rx_ms = 0;
static bool     last_overtime_drop = false;

static uint32_t err_bits = 0; // latched
static bool     err_changed = false;

// Telemetry
static int16_t  dht_temp_c_x10 = (int16_t)0x7FFF;
static uint16_t dht_rh_x10 = 0xFFFF;

static int16_t  ds18_1_c_x10 = (int16_t)0x7FFF;
static int16_t  ds18_2_c_x10 = (int16_t)0x7FFF;

static uint16_t vbat_raw = 0, fwd_raw = 0, rev_raw = 0;
static uint8_t  drive_state = RSCP_DRIVE_OK;
static uint8_t  vswr_state  = RSCP_VSWR_ERR;

// Timers
static uint32_t last_env_ms = 0;
static uint32_t last_rf_ms  = 0;
static uint32_t last_hb_ms  = 0;

// ------------------------- Helpers
static void loadCfg() {
  EEPROM.get(0, cfg);
  if (cfg.magic != MAST_MAGIC) {
    cfg.magic = MAST_MAGIC;
    cfg.stopPttErrMask = (RSCP_ERR_PTT_FAIL | RSCP_ERR_VSWR_HIGH | RSCP_ERR_OVERTIME);
    cfg.pttMaxMs = 300000UL;

    cfg.vbat_low_raw   = 0;
    cfg.vswr1_high_raw = 0;
    cfg.vswr2_high_raw = 0;
    cfg.temp1_high_x10 = 0;
    cfg.temp2_high_x10 = 0;
    cfg.hum_high_pct   = 0;

    EEPROM.put(0, cfg);
  }
}

static void latchErr(uint32_t bit) {
  if ((err_bits & bit) == 0) {
    err_bits |= bit;
    err_changed = true;
  }
}

static void clearErrMask(uint32_t mask) {
  if (mask == 0xFFFFFFFFUL) {
    if (err_bits != 0) err_changed = true;
    err_bits = 0;
  } else {
    uint32_t before = err_bits;
    err_bits &= ~mask;
    if (err_bits != before) err_changed = true;
  }
}

static void canSend8(uint16_t id, const uint8_t d[8]) {
  struct can_frame f{};
  f.can_id  = id;
  f.can_dlc = 8;
  for (uint8_t i = 0; i < 8; i++) f.data[i] = d[i];
  mcp.sendMessage(&f);
}

static void sendHeartbeat() {
  // Suppress heartbeat while PTT is ON (per project requirement)
  if (ptt_requested) return;

  uint8_t d[8] = {0};
  d[0] = RSCP_NODE_MAST;
  d[1] = (ptt_requested ? 0x01 : 0x00);
  uint32_t up_s = millis() / 1000UL;
  rscp_put_u32(&d[2], up_s);
  d[6] = 1;  // fwMajor (placeholder)
  d[7] = 0;  // fwMinor (placeholder)
  canSend8(RSCP_ID_HEARTBEAT, d);
}

static void sendBoot() {
  uint8_t d[8] = {0};
  d[0] = RSCP_NODE_MAST;
  d[1] = 0; // reset cause placeholder
  d[2] = RSCP_PROTO_VER_MAJOR;
  d[3] = RSCP_PROTO_VER_MINOR;
  canSend8(RSCP_ID_BOOT, d);
}

static void sendPttAck(uint8_t result) {
  uint8_t d[8] = {0};

  d[0] = ptt_requested ? RSCP_PTT_ON : RSCP_PTT_OFF;
  d[1] = last_ptt_seq;
  d[2] = result;                    // 0 OK, 1 FAIL
  d[3] = last_overtime_drop ? 1 : 0; // overtimeDrop

  // Clamp latency to uint16 max (Arduino-safe, no templates)
  uint32_t delta = (uint32_t)(millis() - ptt_cmd_rx_ms);
  uint16_t lat = (delta > 65535UL) ? 65535U : (uint16_t)delta;
  rscp_put_u16(&d[4], lat);

  d[6] = 0;                         // flags
  d[7] = RSCP_NODE_MAST;

  canSend8(RSCP_ID_PTT_ACK, d);
}


static void sendErrStatus(uint8_t severity) {
  uint8_t d[8] = {0};
  d[0] = RSCP_NODE_MAST;
  d[1] = severity;
  rscp_put_u32(&d[2], err_bits);
  d[6] = 0; // faultCode
  d[7] = 0; // faultDetail
  canSend8(RSCP_ID_ERR_STATUS, d);
}

static void sendTempReport() {
  uint8_t d[8] = {0};
  d[0] = RSCP_NODE_MAST;
  d[1] = (uint8_t)DS18_COUNT;
  d[2] = 1; // sensorId1
  d[3] = (DS18_COUNT >= 2) ? 2 : 0; // sensorId2
  rscp_put_i16(&d[4], ds18_1_c_x10);
  rscp_put_i16(&d[6], (DS18_COUNT >= 2) ? ds18_2_c_x10 : (int16_t)0x7FFF);
  canSend8(RSCP_ID_TEMP_REPORT, d);
}

static void sendHumReport(uint8_t seq) {
  uint8_t d[8] = {0};
  d[0] = RSCP_NODE_MAST;
#if USE_DHT11
  d[1] = 11;
#elif USE_DHT12
  d[1] = 12;
#else
  d[1] = 0;
#endif
  rscp_put_u16(&d[2], dht_rh_x10);
  rscp_put_i16(&d[4], dht_temp_c_x10);
  d[6] = 0; // status (0 OK; nonzero could be "invalid" later)
  d[7] = seq;
  canSend8(RSCP_ID_HUM_REPORT, d);
}

static void sendRfTelem() {
  uint8_t d[8] = {0};
  rscp_put_u16(&d[0], vbat_raw);
  rscp_put_u16(&d[2], fwd_raw);
  rscp_put_u16(&d[4], rev_raw);
  d[6] = drive_state;
  d[7] = vswr_state;
  canSend8(RSCP_ID_RF_TELEM, d);
}

// Placeholder VSWR calc (calibrate later)
static uint8_t calcVswrState(uint16_t fwd, uint16_t rev) {
  if (fwd == 0 && rev == 0) return RSCP_VSWR_ERR;
  if (rev > (fwd / 2)) return RSCP_VSWR_HIGH;
  return RSCP_VSWR_OK;
}

static uint8_t calcDriveState(uint16_t fwd) {
  if (fwd < 50) return RSCP_DRIVE_LOW;
  if (fwd > 800) return RSCP_DRIVE_HIGH;
  return RSCP_DRIVE_OK;
}

static bool pttConfirmedNow() {
  if (!PTT_SENSE_ENABLE) return true;
  bool s = digitalRead(PIN_PTT_SENSE);
  return PTT_SENSE_ACTIVE_LOW ? (s == LOW) : (s == HIGH);
}

static void applyPttOut(bool on) {
  digitalWrite(PIN_PTT_OUT, on ? HIGH : LOW);
}

// ------------------------- Sensor reading
static bool readDht_x10(int16_t &t10, uint16_t &rh10) {
#if USE_DHT11
  float t = dht.readTemperature();
  float h = dht.readHumidity();
  if (isnan(t) || isnan(h)) return false;

  t10 = (int16_t)(t * 10.0f);
  int rh = (int)(h * 10.0f + 0.5f);
  if (rh < 0) rh = 0;
  if (rh > 1000) rh = 1000;
  rh10 = (uint16_t)rh;
  return true;
#endif

#if USE_DHT12
  // Read 5 bytes: hum_int, hum_dec, temp_int, temp_dec+sign, checksum
  Wire.beginTransmission(DHT12_ADDR);
  Wire.write((uint8_t)0x00);
  if (Wire.endTransmission(false) != 0) return false;

  uint8_t n = Wire.requestFrom((int)DHT12_ADDR, 5);
  if (n != 5) return false;

  uint8_t b[5];
  for (uint8_t i = 0; i < 5; i++) b[i] = Wire.read();

  uint8_t sum = (uint8_t)(b[0] + b[1] + b[2] + b[3]);
  if (sum != b[4]) return false;

  uint16_t hum10 = (uint16_t)(b[0] * 10 + b[1]);
  int16_t temp10 = (int16_t)(b[2] * 10 + (b[3] & 0x7F));
  if (b[3] & 0x80) temp10 = -temp10;

  rh10 = hum10;
  t10 = temp10;
  return true;
#endif
}

static int16_t readDs18_x10(DallasTemperature &bus, bool &ok) {
  ok = false;
  bus.requestTemperatures();
  float t = bus.getTempCByIndex(0);
  if (t == DEVICE_DISCONNECTED_C) return (int16_t)0x7FFF;
  ok = true;
  return (int16_t)(t * 10.0f);
}

// ------------------------- CAN RX
static void processCan() {
  while (mcp.readMessage(&rx) == MCP2515::ERROR_OK) {
    uint16_t id = (uint16_t)(rx.can_id & 0x7FF);

    switch (id) {
      case RSCP_ID_EMERG_PTT_OFF:
        ptt_requested = false;
        applyPttOut(false);
        last_overtime_drop = false;
        sendPttAck(0);
        break;

      case RSCP_ID_PTT_CMD:
        if (rx.can_dlc >= 2) {
          bool on = rx.data[0] != 0;
          last_ptt_seq = rx.data[1];
          ptt_cmd_rx_ms = millis();
          last_overtime_drop = false;

          ptt_requested = on;
          if (on) ptt_on_ms = millis();
          applyPttOut(on);

          // Fast ACK (confirmation is checked in main loop)
          sendPttAck(0);
        }
        break;

      case RSCP_ID_ERR_CLEAR:
        if (rx.can_dlc >= 6) {
          uint8_t target = rx.data[0];
          if (target == RSCP_NODE_MAST || target == 0) {
            uint32_t mask = rscp_get_u32(&rx.data[2]);
            clearErrMask(mask);
            sendErrStatus((err_bits == 0) ? RSCP_SEV_INFO : RSCP_SEV_ERROR);
          }
        }
        break;

      case RSCP_ID_CFG_SET:
        // v1.5 format: [0]=targetNode [1]=key [2..5]=value32 [6]=flags [7]=seq
        if (rx.can_dlc >= 6 && (rx.data[0] == RSCP_NODE_MAST)) {
          uint8_t  key = rx.data[1];
          uint32_t val = rscp_get_u32(&rx.data[2]);

          if      (key == RSCP_CFG_PTT_MAX_MS)        cfg.pttMaxMs = val;
          else if (key == RSCP_CFG_STOP_PTT_ERR_MASK) cfg.stopPttErrMask = val;
          else if (key == RSCP_CFG_VBAT_LOW_RAW)      cfg.vbat_low_raw = val;
          else if (key == RSCP_CFG_VSWR1_HIGH_RAW)    cfg.vswr1_high_raw = val;
          else if (key == RSCP_CFG_VSWR2_HIGH_RAW)    cfg.vswr2_high_raw = val;
          else if (key == RSCP_CFG_TEMP1_HIGH_X10)    cfg.temp1_high_x10 = val;
          else if (key == RSCP_CFG_TEMP2_HIGH_X10)    cfg.temp2_high_x10 = val;
          else if (key == RSCP_CFG_HUM_HIGH_PCT)      cfg.hum_high_pct = val;

          EEPROM.put(0, cfg);

          // ACK: nodeId, key, result, seq, appliedValue32
          uint8_t d[8] = {0};
          d[0] = RSCP_NODE_MAST;
          d[1] = key;
          d[2] = 0; // OK
          d[3] = (rx.can_dlc >= 8) ? rx.data[7] : 0;
          rscp_put_u32(&d[4], val);
          canSend8(RSCP_ID_CFG_ACK, d);
        }
        break;

      default:
        break;
    }
  }
}

// ------------------------- Setup / Loop
void setup() {
  
  Serial.begin(115200);  // delay and message at boot time
  delay(200);
  Serial.println("BOOT");

  pinMode(PIN_LED, OUTPUT);
  digitalWrite(PIN_LED, HIGH);

  pinMode(PIN_PTT_OUT, OUTPUT);
  applyPttOut(false);

  pinMode(PIN_PTT_SENSE, INPUT_PULLUP);

#if USE_DHT11
  dht.begin();
#endif
#if USE_DHT12
  Wire.begin();
#endif

  ds18_1.setWaitForConversion(true);
  ds18_1.begin();
#if DS18_COUNT == 2
  ds18_2.setWaitForConversion(true);
  ds18_2.begin();
#endif

  loadCfg();

  mcp.reset();
  // NOTE: set MCP_8MHZ vs MCP_16MHZ to match your module crystal
  mcp.setBitrate(CAN_500KBPS, MCP_8MHZ);
  mcp.setNormalMode();

  delay(20);
  sendBoot();

  digitalWrite(PIN_LED, LOW);
}

void loop() {
  // 1) Always: CAN RX
  processCan();

  // 2) Always: PTT safety evaluation
  bool confirmed = pttConfirmedNow();

  // Overtime protection
  if (ptt_requested && cfg.pttMaxMs > 0 && (millis() - ptt_on_ms > cfg.pttMaxMs)) {
    latchErr(RSCP_ERR_OVERTIME);
    ptt_requested = false;
    applyPttOut(false);
    last_overtime_drop = true;
    sendPttAck(0);
  }

  // Sense/confirm failure (only when we expect ON)
  if (ptt_requested && PTT_SENSE_ENABLE && !confirmed) {
    latchErr(RSCP_ERR_PTT_FAIL);
    ptt_requested = false;
    applyPttOut(false);
    sendPttAck(1);
  }

  // If any configured STOP errors are set, drop PTT
  if (ptt_requested && (err_bits & cfg.stopPttErrMask)) {
    ptt_requested = false;
    applyPttOut(false);
    sendPttAck(1);
  }

  // Push immediate error status if changed
  if (err_changed) {
    err_changed = false;
    sendErrStatus((err_bits & cfg.stopPttErrMask) ? RSCP_SEV_FATAL : RSCP_SEV_ERROR);
  }

  // 3) Cooperative scheduler
  uint32_t now = millis();

  // Heartbeat (every 5s, suppressed while PTT is ON)
  if (now - last_hb_ms >= 5000) { last_hb_ms = now; sendHeartbeat(); }

  // RF telem (500ms)
  if (now - last_rf_ms >= 500) {
    last_rf_ms = now;

    vbat_raw = analogRead(PIN_VBAT);
    fwd_raw  = analogRead(PIN_FWD);
    rev_raw  = analogRead(PIN_REV);

    vswr_state  = calcVswrState(fwd_raw, rev_raw);
    drive_state = calcDriveState(fwd_raw);

    if (vswr_state == RSCP_VSWR_HIGH) latchErr(RSCP_ERR_VSWR_HIGH);

    sendRfTelem();
  }

  // Env sensors (2s) and temp/hum reports (suppressed while PTT on if enabled)
  static uint8_t humSeq = 0;
  if (now - last_env_ms >= 2000) {
    last_env_ms = now;

    if (SUPPRESS_ENV_WHEN_PTT_ON && ptt_requested) {
      dht_temp_c_x10 = (int16_t)0x7FFF;
      dht_rh_x10 = 0xFFFF;
      ds18_1_c_x10 = (int16_t)0x7FFF;
      ds18_2_c_x10 = (int16_t)0x7FFF;
    } else {
      // DHT
      int16_t t10; uint16_t rh10;
      if (!readDht_x10(t10, rh10)) {
        latchErr(RSCP_ERR_SENSOR_FAIL);
        dht_temp_c_x10 = (int16_t)0x7FFF;
        dht_rh_x10 = 0xFFFF;
      } else {
        dht_temp_c_x10 = t10;
        dht_rh_x10 = rh10;
      }

      // DS18 #1
      bool ok1 = false;
      ds18_1_c_x10 = readDs18_x10(ds18_1, ok1);
      if (!ok1) latchErr(RSCP_ERR_SENSOR_FAIL);

      // DS18 #2 optional
#if DS18_COUNT == 2
      bool ok2 = false;
      ds18_2_c_x10 = readDs18_x10(ds18_2, ok2);
      if (!ok2) latchErr(RSCP_ERR_SENSOR_FAIL);
#else
      ds18_2_c_x10 = (int16_t)0x7FFF;
#endif
    }

    sendTempReport();
    sendHumReport(++humSeq);
    static uint32_t t=0;                                                // alive msg
    if (millis()-t > 1000) { t=millis(); Serial.println("ALIVE"); }     // alive msg

  }

  // LED blink
  static uint32_t lastBlink = 0;
  if (now - lastBlink > 2000) {
    lastBlink = now;
    digitalWrite(PIN_LED, !digitalRead(PIN_LED));
  }
}
