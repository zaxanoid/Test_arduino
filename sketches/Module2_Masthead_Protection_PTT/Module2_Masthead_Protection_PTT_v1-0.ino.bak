// -----------------------------------------------------------------------------
// Module 2: Masthead Protection + PTT (Arduino Nano/Teensy + MCP2515)
// -----------------------------------------------------------------------------
// Pin mappings:
//   LED=4, DHTPIN=8, PSU_Volts=A1, FWD=A2, REV=A3, MCP2515 CS=10
//   PTT_OUT=3, PTT_SENSE=2
//
// Defaults requested:
//   - 1x DHT11 (temp + humidity)
//   - 1x DS18B20 (temp)
//
// Options:
//   - Use DHT12 instead of DHT11 (I2C)
//   - Use 2x DS18B20 (second temp in unused ENV_TELEM bytes [5..6])
//
// Protocol: rscp_can_protocol.h (v1.4)
//   RSCP_ID_ENV_TELEM: temp_c_x10(int16 LE), rh_pct(uint8), ds18_c_x10(int16 LE) or 0x7FFF
// -----------------------------------------------------------------------------

#include <SPI.h>
#include <mcp2515.h>
#include <EEPROM.h>
#include <Arduino.h>

#include "rscp_can_protocol.h"

// ------------------------- Sensor selection (compile-time)
#define USE_DHT11   1
#define USE_DHT12   0     // set 1 to use DHT12 (I2C) instead of DHT11
#define DS18_COUNT  1     // set to 1 or 2

#if (USE_DHT11 + USE_DHT12) != 1
  #error "Select exactly one: USE_DHT11=1 or USE_DHT12=1"
#endif
#if (DS18_COUNT < 1) || (DS18_COUNT > 2)
  #error "DS18_COUNT must be 1 or 2"
#endif

// ------------------------- Pins
static const uint8_t PIN_LED         = 4;

static const uint8_t PIN_DHT         = 8;  // DHT11 data pin (if USE_DHT11)

static const uint8_t PIN_DS18_1      = 7;  // DS18B20 #1 (1-Wire)
static const uint8_t PIN_DS18_2      = 6;  // DS18B20 #2 (optional, if DS18_COUNT==2)

static const uint8_t PIN_PTT_OUT     = 3;  // masthead PTT output (to relay/opto)
static const uint8_t PIN_PTT_SENSE   = 2;  // sense line to confirm PTT switched (optional)
static const bool    PTT_SENSE_ENABLE = true;
static const bool    PTT_SENSE_ACTIVE_LOW = true;

static const uint8_t PIN_CAN_CS      = 10;

// Analog
static const uint8_t PIN_VBAT        = A1;
static const uint8_t PIN_FWD         = A2;
static const uint8_t PIN_REV         = A3;

// OPTIONAL: suppress env sensor reads/telemetry while PTT is ON (RF protection)
static const bool SUPPRESS_ENV_WHEN_PTT_ON = true;

// ------------------------- DHT
#if USE_DHT11
  #include <DHT.h>
  static const uint8_t DHTTYPE = DHT11;
  DHT dht(PIN_DHT, DHTTYPE);
#endif

#if USE_DHT12
  #include <Wire.h>
  static const uint8_t DHT12_ADDR = 0x5C; // common DHT12 I2C address
#endif

// ------------------------- DS18B20
#include <OneWire.h>
#include <DallasTemperature.h>

static OneWire ow1(PIN_DS18_1);
static DallasTemperature ds18_1(&ow1);

#if DS18_COUNT == 2
static OneWire ow2(PIN_DS18_2);
static DallasTemperature ds18_2(&ow2);
#endif

// ------------------------- CAN
MCP2515 mcp(PIN_CAN_CS);
struct can_frame rx;

// ------------------------- Settings in EEPROM
struct MastSettings {
  uint32_t magic;
  uint32_t stopPttErrMask; // RSCP_ERR_* bitmask
  uint32_t pttMaxMs;
  // Threshold placeholders (calibrate later)
  uint32_t vbat_low_raw;
  uint32_t vswr1_high_raw;
  uint32_t vswr2_high_raw;
  uint32_t temp1_high_x10;
  uint32_t temp2_high_x10;
  uint32_t hum_high_pct;
};

static const uint32_t MAST_MAGIC = 0x4D415354; // "MAST"
MastSettings cfg;

// ------------------------- Runtime state
static bool     ptt_requested = false;
static uint8_t  last_ptt_seq = 0;
static uint32_t ptt_on_ms = 0;

static uint32_t err_bits = 0; // latched
static bool     err_changed = false;

// Telemetry
static int16_t  temp_c_x10 = (int16_t)0x7FFF;
static uint8_t  rh_pct = 0xFF;
static int16_t  ds18_1_c_x10 = (int16_t)0x7FFF;
static int16_t  ds18_2_c_x10 = (int16_t)0x7FFF;

static uint16_t vbat_raw = 0, fwd_raw = 0, rev_raw = 0;
static uint8_t  drive_state = RSCP_DRIVE_OK;
static uint8_t  vswr_state  = RSCP_VSWR_ERR;

// Timers
static uint32_t last_env_ms = 0;
static uint32_t last_rf_ms  = 0;
static uint32_t last_hb_ms  = 0;

// ------------------------- Helpers
static void loadCfg() {
  EEPROM.get(0, cfg);
  if (cfg.magic != MAST_MAGIC) {
    cfg.magic = MAST_MAGIC;
    cfg.stopPttErrMask = (RSCP_ERR_PTT_FAIL | RSCP_ERR_VSWR_HIGH | RSCP_ERR_OVERTIME);
    cfg.pttMaxMs = 300000UL;

    cfg.vbat_low_raw   = 0;
    cfg.vswr1_high_raw = 0;
    cfg.vswr2_high_raw = 0;
    cfg.temp1_high_x10 = 0;
    cfg.temp2_high_x10 = 0;
    cfg.hum_high_pct   = 0;

    EEPROM.put(0, cfg);
  }
}

static void latchErr(uint32_t bit) {
  if ((err_bits & bit) == 0) {
    err_bits |= bit;
    err_changed = true;
  }
}

static void clearErrMask(uint32_t mask) {
  if (mask == 0xFFFFFFFFUL) {
    if (err_bits != 0) err_changed = true;
    err_bits = 0;
  } else {
    uint32_t before = err_bits;
    err_bits &= ~mask;
    if (err_bits != before) err_changed = true;
  }
}

static void canSend8(uint16_t id, const uint8_t d[8]) {
  struct can_frame f{};
  f.can_id  = id;
  f.can_dlc = 8;
  for (uint8_t i = 0; i < 8; i++) f.data[i] = d[i];
  mcp.sendMessage(&f);
}

static void sendHeartbeat() {
  uint8_t d[8] = {0};
  d[0] = RSCP_MOD_MAST;
  d[1] = (ptt_requested ? 0x01 : 0x00);
  uint32_t up_s = millis() / 1000UL;
  rscp_put_u32(&d[2], up_s);
  canSend8(RSCP_ID_HEARTBEAT, d);
}

static void sendBoot() {
  uint8_t d[8] = {0};
  d[0] = RSCP_MOD_MAST;
  d[1] = 0; // reset cause placeholder
  d[2] = RSCP_PROTO_VER_MAJOR;
  d[3] = RSCP_PROTO_VER_MINOR;
  canSend8(RSCP_ID_BOOT, d);
}

static void sendPttStatus(bool confirmed) {
  uint8_t d[8] = {0};
  d[0] = ptt_requested ? RSCP_PTT_ON : RSCP_PTT_OFF;
  d[1] = last_ptt_seq;
  d[2] = confirmed ? 0x01 : 0x00;        // status_flags bit0=confirmed
  d[3] = (err_bits != 0) ? 1 : 0;         // err_latched flag
  canSend8(RSCP_ID_PTT_STATUS, d);
}

static void sendErrStatus(uint8_t severity) {
  uint8_t d[8] = {0};
  d[0] = RSCP_MOD_MAST;
  d[1] = severity;
  rscp_put_u32(&d[2], err_bits);
  canSend8(RSCP_ID_ERR_STATUS, d);
}

static void sendEnvTelem() {
  // RSCP_ID_ENV_TELEM (header-defined fields):
  //   [0..1] temp_c_x10 (int16)
  //   [2]    rh_pct (uint8)
  //   [3..4] ds18_c_x10 (int16) or 0x7FFF
  // Additional (safe): [5..6] ds18_2_c_x10 (int16) if present, else 0x7FFF
  uint8_t d[8] = {0};

  rscp_put_i16(&d[0], temp_c_x10);
  d[2] = rh_pct;
  rscp_put_i16(&d[3], ds18_1_c_x10);
  rscp_put_i16(&d[5], ds18_2_c_x10);
  d[7] = 0;

  canSend8(RSCP_ID_ENV_TELEM, d);
}

static void sendRfTelem() {
  uint8_t d[8] = {0};
  rscp_put_u16(&d[0], vbat_raw);
  rscp_put_u16(&d[2], fwd_raw);
  rscp_put_u16(&d[4], rev_raw);
  d[6] = drive_state;
  d[7] = vswr_state;
  canSend8(RSCP_ID_RF_TELEM, d);
}

// Placeholder VSWR calc (calibrate later)
static uint8_t calcVswrState(uint16_t fwd, uint16_t rev) {
  if (fwd == 0 && rev == 0) return RSCP_VSWR_ERR;
  if (rev > (fwd / 2)) return RSCP_VSWR_HIGH;
  return RSCP_VSWR_OK;
}

static uint8_t calcDriveState(uint16_t fwd) {
  if (fwd < 50) return RSCP_DRIVE_LOW;
  if (fwd > 800) return RSCP_DRIVE_HIGH;
  return RSCP_DRIVE_OK;
}

static bool pttConfirmedNow() {
  if (!PTT_SENSE_ENABLE) return true;
  bool s = digitalRead(PIN_PTT_SENSE);
  return PTT_SENSE_ACTIVE_LOW ? (s == LOW) : (s == HIGH);
}

static void applyPttOut(bool on) {
  digitalWrite(PIN_PTT_OUT, on ? HIGH : LOW);
}

// ------------------------- Sensor reading
static bool readDht_x10(int16_t &t10, uint8_t &rh) {
#if USE_DHT11
  float t = dht.readTemperature();
  float h = dht.readHumidity();
  if (isnan(t) || isnan(h)) return false;

  t10 = (int16_t)(t * 10.0f);
  int hi = (int)(h + 0.5f);
  if (hi < 0) hi = 0;
  if (hi > 100) hi = 100;
  rh = (uint8_t)hi;
  return true;
#endif

#if USE_DHT12
  // Read 5 bytes: hum_int, hum_dec, temp_int, temp_dec+sign, checksum
  Wire.beginTransmission(DHT12_ADDR);
  Wire.write((uint8_t)0x00);
  if (Wire.endTransmission(false) != 0) return false;

  uint8_t n = Wire.requestFrom((int)DHT12_ADDR, 5);
  if (n != 5) return false;

  uint8_t b[5];
  for (uint8_t i = 0; i < 5; i++) b[i] = Wire.read();

  uint8_t sum = (uint8_t)(b[0] + b[1] + b[2] + b[3]);
  if (sum != b[4]) return false;

  rh = b[0];

  int16_t temp10 = (int16_t)(b[2] * 10 + (b[3] & 0x7F));
  if (b[3] & 0x80) temp10 = -temp10;
  t10 = temp10;
  return true;
#endif
}

static int16_t readDs18_x10(DallasTemperature &bus, bool &ok) {
  ok = false;
  bus.requestTemperatures();
  float t = bus.getTempCByIndex(0);
  if (t == DEVICE_DISCONNECTED_C) return (int16_t)0x7FFF;
  ok = true;
  return (int16_t)(t * 10.0f);
}

// ------------------------- CAN RX
static void processCan() {
  while (mcp.readMessage(&rx) == MCP2515::ERROR_OK) {
    uint16_t id = (uint16_t)(rx.can_id & 0x7FF);

    switch (id) {
      case RSCP_ID_EMERG_PTT_OFF:
        ptt_requested = false;
        applyPttOut(false);
        sendPttStatus(false);
        break;

      case RSCP_ID_PTT_CMD:
        if (rx.can_dlc >= 2) {
          bool on = rx.data[0] != 0;
          last_ptt_seq = rx.data[1];
          ptt_requested = on;
          if (on) ptt_on_ms = millis();
          applyPttOut(on);
          // confirm check happens in main loop
        }
        break;

      case RSCP_ID_ERR_CLEAR:
        if (rx.can_dlc >= 6) {
          uint8_t target = rx.data[0];
          if (target == RSCP_MOD_MAST || target == 0) {
            uint32_t mask = rscp_get_u32(&rx.data[2]);
            clearErrMask(mask);
            sendErrStatus((err_bits == 0) ? RSCP_SEV_INFO : RSCP_SEV_ERROR);
          }
        }
        break;

      case RSCP_ID_CFG_SET:
        // header: module_id, key, value at data[2..5]
        if (rx.can_dlc >= 6 && rx.data[0] == RSCP_MOD_MAST) {
          uint8_t  key = rx.data[1];
          uint32_t val = rscp_get_u32(&rx.data[2]);

          if      (key == RSCP_CFG_PTT_MAX_MS)        cfg.pttMaxMs = val;
          else if (key == RSCP_CFG_STOP_PTT_ERR_MASK) cfg.stopPttErrMask = val;
          else if (key == RSCP_CFG_VBAT_LOW_RAW)      cfg.vbat_low_raw = val;
          else if (key == RSCP_CFG_VSWR1_HIGH_RAW)    cfg.vswr1_high_raw = val;
          else if (key == RSCP_CFG_VSWR2_HIGH_RAW)    cfg.vswr2_high_raw = val;
          else if (key == RSCP_CFG_TEMP1_HIGH_X10)    cfg.temp1_high_x10 = val;
          else if (key == RSCP_CFG_TEMP2_HIGH_X10)    cfg.temp2_high_x10 = val;
          else if (key == RSCP_CFG_HUM_HIGH_PCT)      cfg.hum_high_pct = val;

          EEPROM.put(0, cfg);

          // ACK (8 bytes)
          uint8_t d[8] = {0};
          d[0] = RSCP_MOD_MAST;
          d[1] = key;
          d[2] = 0; // status ok
          canSend8(RSCP_ID_CFG_ACK, d);
        }
        break;

      default:
        break;
    }
  }
}

// ------------------------- Setup / Loop
void setup() {
  pinMode(PIN_LED, OUTPUT);
  digitalWrite(PIN_LED, HIGH);

  pinMode(PIN_PTT_OUT, OUTPUT);
  applyPttOut(false);

  pinMode(PIN_PTT_SENSE, INPUT_PULLUP);

#if USE_DHT11
  dht.begin();
#endif
#if USE_DHT12
  Wire.begin();
#endif

  ds18_1.setWaitForConversion(true);
  ds18_1.begin();
#if DS18_COUNT == 2
  ds18_2.setWaitForConversion(true);
  ds18_2.begin();
#endif

  loadCfg();

  mcp.reset();
  // NOTE: set MCP_8MHZ vs MCP_16MHZ to match your module crystal
  mcp.setBitrate(CAN_500KBPS, MCP_8MHZ);
  mcp.setNormalMode();

  delay(20);
  sendBoot();

  digitalWrite(PIN_LED, LOW);
}

void loop() {
  // 1) Always: CAN RX
  processCan();

  // 2) Always: PTT safety evaluation
  bool confirmed = pttConfirmedNow();

  // Overtime protection
  if (ptt_requested && cfg.pttMaxMs > 0 && (millis() - ptt_on_ms > cfg.pttMaxMs)) {
    latchErr(RSCP_ERR_OVERTIME);
    ptt_requested = false;
    applyPttOut(false);
  }

  // Sense/confirm failure
  if (ptt_requested && PTT_SENSE_ENABLE && !confirmed) {
    latchErr(RSCP_ERR_PTT_FAIL);
    ptt_requested = false;
    applyPttOut(false);
  }

  // If any configured STOP errors are set, drop PTT
  if (ptt_requested && (err_bits & cfg.stopPttErrMask)) {
    ptt_requested = false;
    applyPttOut(false);
  }

  // Push immediate error status if changed
  if (err_changed) {
    err_changed = false;
    sendErrStatus((err_bits & cfg.stopPttErrMask) ? RSCP_SEV_FATAL : RSCP_SEV_ERROR);
  }

  // Report PTT status on state changes only
  static bool prev_ptt = false;
  if (ptt_requested != prev_ptt) {
    prev_ptt = ptt_requested;
    sendPttStatus(confirmed && ptt_requested);
  }

  // 3) Cooperative scheduler: one non-PTT task per loop
  static uint8_t rr = 0;
  rr = (rr + 1) % 5;

  uint32_t now = millis();

  if (rr == 0) {
    // Heartbeat every 1s
    if (now - last_hb_ms >= 1000) { last_hb_ms = now; sendHeartbeat(); }

  } else if (rr == 1) {
    // Env sensors every 2s (optional suppress while PTT on)
    if (now - last_env_ms >= 2000) {
      last_env_ms = now;

      if (SUPPRESS_ENV_WHEN_PTT_ON && ptt_requested) {
        // mark invalid + don't spam errors due to RF
        temp_c_x10 = (int16_t)0x7FFF;
        rh_pct = 0xFF;
        ds18_1_c_x10 = (int16_t)0x7FFF;
        ds18_2_c_x10 = (int16_t)0x7FFF;
      } else {
        // DHT
        int16_t t10;
        uint8_t rh;
        if (!readDht_x10(t10, rh)) {
          latchErr(RSCP_ERR_SENSOR_FAIL);
          temp_c_x10 = (int16_t)0x7FFF;
          rh_pct = 0xFF;
        } else {
          temp_c_x10 = t10;
          rh_pct = rh;
        }

        // DS18 #1
        bool ok1 = false;
        ds18_1_c_x10 = readDs18_x10(ds18_1, ok1);
        if (!ok1) latchErr(RSCP_ERR_SENSOR_FAIL);

        // DS18 #2 optional
#if DS18_COUNT == 2
        bool ok2 = false;
        ds18_2_c_x10 = readDs18_x10(ds18_2, ok2);
        if (!ok2) latchErr(RSCP_ERR_SENSOR_FAIL);
#else
        ds18_2_c_x10 = (int16_t)0x7FFF;
#endif
      }

      sendEnvTelem();
    }

  } else if (rr == 2) {
    // reserved

  } else if (rr == 3) {
    // RF telem at 500ms
    if (now - last_rf_ms >= 500) {
      last_rf_ms = now;

      vbat_raw = analogRead(PIN_VBAT);
      fwd_raw  = analogRead(PIN_FWD);
      rev_raw  = analogRead(PIN_REV);

      vswr_state  = calcVswrState(fwd_raw, rev_raw);
      drive_state = calcDriveState(fwd_raw);

      if (vswr_state == RSCP_VSWR_HIGH) latchErr(RSCP_ERR_VSWR_HIGH);

      sendRfTelem();
    }

  } else {
    // LED blink / spare
    static uint32_t lastBlink = 0;
    if (now - lastBlink > 2000) {
      lastBlink = now;
      digitalWrite(PIN_LED, !digitalRead(PIN_LED));
    }
  }
}
