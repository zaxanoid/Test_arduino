#include <Arduino.h>
#include <Wire.h>
#include <EEPROM.h>
#include <SPI.h>
#include <mcp2515.h>
#include "rscp_can_protocol.h"

// ---- PTT_STATUS flag bits (v1.4 uses raw bitfield in data[2]) ----
#ifndef RSCP_PTTSTAT_CONFIRMED
#define RSCP_PTTSTAT_CONFIRMED 0x01
#define RSCP_PTTSTAT_INHIBITED 0x02
#define RSCP_PTTSTAT_OVERTIME  0x04
#endif


// ======================================================
// ===== DISPLAY SELECTION ===============================
// ======================================================

// Default = 20x4 I2C LCD
// Uncomment to force 16x2
// #define USE_LCD_16x2

#define LCD_I2C_ADDR 0x27

#ifdef USE_LCD_16x2
  #include <LiquidCrystal_I2C.h>
  LiquidCrystal_I2C lcd(LCD_I2C_ADDR, 16, 2);
#else
  #include <LiquidCrystal_I2C.h>
  LiquidCrystal_I2C lcd(LCD_I2C_ADDR, 20, 4);
#endif

// ======================================================
// ===== PIN DEFINITIONS =================================
// ======================================================

static const uint8_t PIN_PTT_IN   = 3;   // external PTT input
static const uint8_t PIN_PTT_OUT  = 4;   // PTT confirm output
static const uint8_t PIN_PTT_LED  = 5;   // PTT status LED
static const uint8_t PIN_BTN      = 2;   // UI button (pullup)
static uint32_t lastRfMs  = 0;
static uint32_t lastEnvMs = 0;
static uint32_t lastM2RxMs = 0;  // any message from Module 2
static bool haveEnv = false;   // TEMP: set true when first ENV_TELEM received
static bool haveRf  = false;   // TEMP: set true when first RF_TELEM received

// ---- PTT handshake state ----
static bool    ptt_active    = false;  // local requested PTT state
static bool    ptt_confirmed = false;  // true only when mast confirms PTT and no errors
static uint8_t last_cmd_seq  = 0;      // last PTT_CMD sequence we sent
static bool    ptt_in_active = false;  // external PTT input state (debounced)

// MCP2515
static const uint8_t CAN_CS_PIN   = 10;

// ======================================================
// ===== SETTINGS STRUCT (FIXED) =========================
// ======================================================

struct Settings {
  uint32_t ptt_max_ms;
  uint16_t compass_period_ms;
  uint16_t rotator_period_ms;
  uint32_t stop_ptt_err_mask;

  // Module 2 thresholds (RAW / placeholder)
  uint16_t vbat_low_raw;
  uint16_t vswr1_high_raw;
  uint16_t vswr2_high_raw;
  int16_t  temp1_high_x10;
  int16_t  temp2_high_x10;
  uint8_t  hum_high_pct;
  uint8_t  ptt_confirm_enable; // 0=disabled(default),1=require remote confirm
};

Settings settings;

// ======================================================
// ===== TELEMETRY STATE =================================
// ======================================================

static uint32_t mast_err_bits = 0;

struct MastState {
  uint16_t vbat_raw;
  uint8_t  vswr_state;
  uint8_t  drive_state;
  int16_t  temp_x10;
  uint8_t  humidity;
  uint32_t err_flags;
} mast;

uint16_t compass_deg = 0;
uint16_t rotator_deg = 0;
// bool ptt_active defined in PTT HANDSHAKE section
// bool ptt_confirmed defined in PTT HANDSHAKE section
// Heartbeats
bool alive_m2 = false;
bool alive_m3 = false;
bool alive_m4 = false;

// CFG ACK status
uint8_t cfgAckM2 = 0xFF;
uint8_t cfgAckM3 = 0xFF;
uint8_t cfgAckM4 = 0xFF;

// ======================================================
// ===== CAN =============================================
// ======================================================

MCP2515 mcp2515(CAN_CS_PIN);
struct can_frame canRx;
struct can_frame canTx;

// ======================================================
// ===== HELPERS =========================================
// ======================================================

static const char* vswrText(uint8_t s) {
  switch (s) {
    case 0: return "OK ";
    case 1: return "HIG";
    default:return "ERR";
  }
}

static const char* driveText(uint8_t s) {
  switch (s) {
    case 0: return "OK ";
    case 1: return "LOW";
    default:return "HIG";
  }
}

float vbatVoltsFromRaw(uint16_t raw) {
  // Placeholder â€“ scaling later
  return raw * 0.01f;
}

// ======================================================
// ===== EEPROM ==========================================
// ======================================================

void saveSettings() {
  EEPROM.put(0, settings);
}

void loadSettings() {
  EEPROM.get(0, settings);

  if (settings.ptt_max_ms == 0xFFFFFFFFUL) {
    settings.ptt_max_ms        = 300000;
    settings.compass_period_ms = 500;
    settings.rotator_period_ms = 500;
    settings.stop_ptt_err_mask = 0x000000FF;

    settings.vbat_low_raw     = 0;
    settings.vswr1_high_raw   = 0;
    settings.vswr2_high_raw   = 0;
    settings.temp1_high_x10   = 0;
    settings.temp2_high_x10   = 0;
    settings.hum_high_pct     = 0;


    settings.ptt_confirm_enable = 0;
    saveSettings();
  }
}

// ======================================================
// ===== CAN TX ==========================================
// ======================================================

void sendCfg(uint8_t destModule, uint8_t key, uint32_t value) {
  canTx.can_id  = RSCP_ID_CFG_SET;
  canTx.can_dlc = 8;
  memset(canTx.data, 0, 8);
  canTx.data[0] = destModule;
  canTx.data[1] = key;
  rscp_put_u32(&canTx.data[4], value);
  mcp2515.sendMessage(&canTx);
}

void pushSettingsToRemotes() {
  // Module 2 (masthead)
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_PTT_MAX_MS,        settings.ptt_max_ms);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_PTT_CONFIRM_ENABLE, (uint32_t)settings.ptt_confirm_enable);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_STOP_PTT_ERR_MASK, settings.stop_ptt_err_mask);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_VBAT_LOW_RAW,      settings.vbat_low_raw);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_VSWR1_HIGH_RAW,    settings.vswr1_high_raw);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_VSWR2_HIGH_RAW,    settings.vswr2_high_raw);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_TEMP1_HIGH_X10,    (uint32_t)(int32_t)settings.temp1_high_x10);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_TEMP2_HIGH_X10,    (uint32_t)(int32_t)settings.temp2_high_x10);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_HUM_HIGH_PCT,      settings.hum_high_pct);

  // Module 3 + 4 periods
  sendCfg(RSCP_MOD_COMPASS, RSCP_CFG_COMPASS_PERIOD_MS, settings.compass_period_ms);
  sendCfg(RSCP_MOD_ROTATOR, RSCP_CFG_ROTATOR_PERIOD_MS, settings.rotator_period_ms);

  cfgAckM2 = cfgAckM3 = cfgAckM4 = 0xFF;
}

// ======================================================
// ===== CAN RX ==========================================
// ======================================================

void processCan() {
  while (mcp2515.readMessage(&canRx) == MCP2515::ERROR_OK) {
#if RSCP_DEBUG_CAN_RX
    dbgPrintRx(canRx);
#endif
    switch (canRx.can_id) {

      
      case RSCP_ID_PTT_STATUS: {
        // data0=state, data1=seq, data2=status_flags, data3=err_latched
        const uint8_t state = canRx.data[0];
        const uint8_t seq   = canRx.data[1];
        const uint8_t flags = canRx.data[2];
        const bool errLatched = (canRx.data[3] != 0);

        const bool remoteOn = (state == RSCP_PTT_ON) && !errLatched && ((flags & RSCP_PTTSTAT_INHIBITED) == 0);
        const bool remoteConfirmed = ((flags & RSCP_PTTSTAT_CONFIRMED) != 0);
        const bool remoteOk = remoteOn && (settings.ptt_confirm_enable ? remoteConfirmed : true);

        // Only accept status for the most recent command sequence when ON, but always accept OFF as a safety drop.
        if (seq == last_cmd_seq) {
          ptt_confirmed = remoteOk;
        } else {
          if (state == RSCP_PTT_OFF) ptt_confirmed = false;
        }

        alive_m2 = true;
        lastM2RxMs = millis();
        break;
      }

      case RSCP_ID_ERR_STATUS: {
        // data0=module_id, data1=severity, data2..5=err_bits(uint32)
        const uint8_t mod = canRx.data[0];
        const uint8_t sev = canRx.data[1];
        const uint32_t bits = rscp_get_u32(&canRx.data[2]);

        if (mod == RSCP_MOD_MAST) {
          mast_err_bits = bits;
        }
        // Basic safety: any ERROR/FATAL from mast drops confirmed PTT
        if (mod == RSCP_MOD_MAST && (sev >= RSCP_SEV_ERROR) && bits != RSCP_ERR_NONE) {
          ptt_confirmed = false;
        }
        break;
      }

      case RSCP_ID_ENV_TELEM:
        mast.temp_x10 = rscp_get_i16(&canRx.data[0]);
        mast.humidity = canRx.data[2];
        mast.vbat_raw = rscp_get_u16(&canRx.data[3]);
        lastEnvMs = millis();
        haveEnv = true;
        alive_m2 = true;
        lastM2RxMs = lastEnvMs;
        break;

      case RSCP_ID_RF_TELEM:
        mast.vswr_state  = canRx.data[0];
        mast.drive_state = canRx.data[1];
        lastRfMs = millis();
        haveRf = true;
        alive_m2 = true;
        lastM2RxMs = lastRfMs;
        break;

      case RSCP_ID_HEARTBEAT: {
        // data0=node_id, data1=ptt_active, data2..5=uptime_ms (u32 LE), data6=err_latched, data7=seq
        const uint8_t node = canRx.data[0];
        if (node == RSCP_MOD_MAST) {
          alive_m2 = true;
          lastM2RxMs = millis();
        }
        // (Optional future: handle compass/rot heartbeat when those modules implement it)
        break;
      }

      case RSCP_ID_HEADING:
        compass_deg = rscp_get_u16(&canRx.data[0]);
        alive_m3 = true;
        break;

      case RSCP_ID_ROT_STATUS:
        rotator_deg = rotator_deg = rscp_get_u16(&canRx.data[0]);
        alive_m4 = true;
        break;

      case RSCP_ID_CFG_ACK:
        if (canRx.data[0] == RSCP_MOD_MAST)    cfgAckM2 = canRx.data[1];
        if (canRx.data[0] == RSCP_MOD_COMPASS) cfgAckM3 = canRx.data[1];
        if (canRx.data[0] == RSCP_MOD_ROTATOR) cfgAckM4 = canRx.data[1];

        // Treat any cfg ack as proof of life
        if (canRx.data[0] == RSCP_MOD_MAST) { alive_m2 = true; lastM2RxMs = millis(); }
        break;
    }
  }
}

// ======================================================
// ===== UI ==============================================
// ======================================================

void renderLCD() {
  const uint32_t now = millis();
  const bool rfValid  = haveRf  && (now - lastRfMs)  <= 4000UL;
  const bool envValid = haveEnv && (now - lastEnvMs) <= 6000UL;
  const bool m2Alive  = (lastM2RxMs != 0) && ((now - lastM2RxMs) < 3000UL);

  // Line 0: VSWR + Drive
  lcd.setCursor(0,0);
  lcd.print("VSWR:");
  lcd.print(!rfValid ? "N/A" : vswrText(mast.vswr_state));
  lcd.print(" ");
  lcd.setCursor(9,0);
  lcd.print("DRV:");
  lcd.print(!rfValid ? "N/A" : driveText(mast.drive_state));
  lcd.print(" ");

  // Line 1: Temp + Voltage
  lcd.setCursor(0,1);
  lcd.print("Temp:");
  if (!envValid) {
    lcd.print("N/A ");
  } else {
    lcd.print(mast.temp_x10 / 10.0, 1);
    lcd.print(" ");
  }
  lcd.setCursor(9,1);
  lcd.print("V:");
  if (!envValid) {
    lcd.print("N/A ");
  } else {
    lcd.print(vbatVoltsFromRaw(mast.vbat_raw), 1);
    lcd.print(" ");
  }

#ifndef USE_LCD_16x2
  // Line 2: Bearings
  lcd.setCursor(0,2);
  lcd.print("Bear:");
  lcd.print(compass_deg);
  lcd.print(" Rot:");
  lcd.print(rotator_deg);
  lcd.print("    ");

  // Line 3: PTT state + Error + module alive
  lcd.setCursor(0,3);
  lcd.print("PTT:");
  if (!ptt_in_active) {
    lcd.print("OFF");
  } else if (ptt_confirmed) {
    lcd.print("ON ");
  } else {
    lcd.print("REQ");
  }
  lcd.print(" E:");
  if (!m2Alive) {
    lcd.print("-");
  } else {
    lcd.print(mast.err_flags ? "Y" : "N");
  }
  lcd.print(" ");
  lcd.print(m2Alive ? "2" : "-");
  lcd.print(alive_m3 ? "3" : "-");
  lcd.print(alive_m4 ? "4" : "-");
  lcd.print("   ");
#endif
}

// ======================================================
// ===== PTT =============================================
// ======================================================


// ======================================================
// ===== PTT HANDSHAKE ==================================
// ======================================================

// Local PTT state
static uint8_t  ptt_seq = 0;              // increments on each command edge
static uint32_t last_ptt_cmd_ms = 0;

static inline void sendPttCmd(uint8_t onoff) {
  uint8_t d[8] = {0};
  d[0] = onoff ? RSCP_PTT_ON : RSCP_PTT_OFF;
  d[1] = ++ptt_seq;
  d[2] = 0; // flags reserved
  last_cmd_seq = ptt_seq;
  last_ptt_cmd_ms = millis();
  // Track local PTT request state (confirmation comes from RSCP_ID_PTT_STATUS)
  ptt_active = (onoff != 0);
  if (!ptt_active) ptt_confirmed = false;

  canTx.can_id  = RSCP_ID_PTT_CMD;
  canTx.can_dlc = 8;
  memcpy(canTx.data, d, 8);
  mcp2515.sendMessage(&canTx);
}

void handlePtt() {
  // External PTT input: active HIGH (10k pulldown fitted)
  const uint32_t now = millis();
  const bool raw = (digitalRead(PIN_PTT_IN) == HIGH);

  // Minimal debounce (edge-cleaning) without slowing the fast loop
  static bool last_raw = false;
  static bool stable = false;
  static uint32_t last_change_ms = 0;
  if (raw != last_raw) {
    last_raw = raw;
    last_change_ms = now;
  }
  if ((now - last_change_ms) >= 5) {
    stable = last_raw;
  }

  const bool in = stable;

  // Rising edge: request PTT
  if (in && !ptt_in_active) {
    sendPttCmd(1);
    ptt_in_active = true;
    // do NOT assert PIN_PTT_OUT until remote reports ON (and confirm, if enabled)
  }

  // Falling edge: drop PTT immediately (and clear confirmation)
  if (!in && ptt_in_active) {
    sendPttCmd(0);
    ptt_in_active = false;
    ptt_confirmed = false;
  }

  // LED reflects local request; OUT reflects remote OK per policy
  digitalWrite(PIN_PTT_LED, ptt_active);
  digitalWrite(PIN_PTT_OUT, ptt_confirmed);
}


// ======================================================
// ===== SETUP / LOOP ===================================
// ======================================================

void setup() {
  pinMode(PIN_PTT_IN, INPUT);  // active HIGH with external 10k pulldown
  pinMode(PIN_PTT_OUT, OUTPUT);
  pinMode(PIN_PTT_LED, OUTPUT);
  pinMode(PIN_BTN, INPUT_PULLUP);

  Wire.begin();
  lcd.init();
  lcd.backlight();

  // ===== TEMP SERIAL DEBUG (COMMENT OUT LATER) =====
  Serial.begin(115200);
  delay(800);
  Serial.println("Module1 boot");
  // ================================================

  SPI.begin();
  mcp2515.reset();
  mcp2515.setBitrate(CAN_500KBPS, MCP_8MHZ);
  mcp2515.setNormalMode();

  loadSettings();
  lcd.clear();
}

void loop() {
  processCan();   // priority
  handlePtt();    // priority
  renderLCD();    // one lightweight task
}