#include <Arduino.h>
#include <Wire.h>
#include <EEPROM.h>
#include <SPI.h>
#include <mcp2515.h>
#include "rscp_can_protocol.h"

// ---- PTT_STATUS flag bits (v1.4 uses raw bitfield in data[2]) ----
#ifndef RSCP_PTTSTAT_CONFIRMED
#define RSCP_PTTSTAT_CONFIRMED 0x01
#define RSCP_PTTSTAT_INHIBITED 0x02
#define RSCP_PTTSTAT_OVERTIME  0x04
#endif


// ======================================================
// ===== DISPLAY SELECTION ===============================
// ======================================================

// Default = 20x4 I2C LCD
// Uncomment to force 16x2
// #define USE_LCD_16x2

#define LCD_I2C_ADDR 0x27

#ifdef USE_LCD_16x2
  #include <LiquidCrystal_I2C.h>
  LiquidCrystal_I2C lcd(LCD_I2C_ADDR, 16, 2);
#else
  #include <LiquidCrystal_I2C.h>
  LiquidCrystal_I2C lcd(LCD_I2C_ADDR, 20, 4);
#endif

// ======================================================
// ===== PIN DEFINITIONS =================================
// ======================================================

static const uint8_t PIN_PTT_IN   = 3;   // external PTT input
static const uint8_t PIN_PTT_OUT  = 4;   // PTT confirm output
static const uint8_t PIN_PTT_LED  = 5;   // PTT status LED
static const uint8_t PIN_BTN      = 2;   // UI button (pullup)
static uint32_t lastRfMs  = 0;
static uint32_t lastEnvMs = 0;

// ---- PTT handshake state ----
static bool    ptt_active    = false;  // local requested PTT state
static bool    ptt_confirmed = false;  // true only when mast confirms PTT and no errors
static uint8_t last_cmd_seq  = 0;      // last PTT_CMD sequence we sent

// MCP2515
static const uint8_t CAN_CS_PIN   = 10;

// ======================================================
// ===== SETTINGS STRUCT (FIXED) =========================
// ======================================================

struct Settings {
  uint32_t ptt_max_ms;
  uint16_t compass_period_ms;
  uint16_t rotator_period_ms;
  uint32_t stop_ptt_err_mask;

  // Module 2 thresholds (RAW / placeholder)
  uint16_t vbat_low_raw;
  uint16_t vswr1_high_raw;
  uint16_t vswr2_high_raw;
  int16_t  temp1_high_x10;
  int16_t  temp2_high_x10;
  uint8_t  hum_high_pct;
};

Settings settings;

// ======================================================
// ===== TELEMETRY STATE =================================
// ======================================================

static uint32_t mast_err_bits = 0;

struct MastState {
  uint16_t vbat_raw;
  uint8_t  vswr_state;
  uint8_t  drive_state;
  int16_t  temp_x10;
  uint8_t  humidity;
  uint32_t err_flags;
} mast;

uint16_t compass_deg = 0;
uint16_t rotator_deg = 0;
// bool ptt_active defined in PTT HANDSHAKE section
// bool ptt_confirmed defined in PTT HANDSHAKE section
// Heartbeats
bool alive_m2 = false;
bool alive_m3 = false;
bool alive_m4 = false;

// CFG ACK status
uint8_t cfgAckM2 = 0xFF;
uint8_t cfgAckM3 = 0xFF;
uint8_t cfgAckM4 = 0xFF;

// ======================================================
// ===== CAN =============================================
// ======================================================

MCP2515 mcp2515(CAN_CS_PIN);
struct can_frame canRx;
struct can_frame canTx;

// ======================================================
// ===== HELPERS =========================================
// ======================================================

static const char* vswrText(uint8_t s) {
  switch (s) {
    case 0: return "OK ";
    case 1: return "HIG";
    default:return "ERR";
  }
}

static const char* driveText(uint8_t s) {
  switch (s) {
    case 0: return "OK ";
    case 1: return "LOW";
    default:return "HIG";
  }
}

float vbatVoltsFromRaw(uint16_t raw) {
  // Placeholder â€“ scaling later
  return raw * 0.01f;
}

// ======================================================
// ===== EEPROM ==========================================
// ======================================================

void saveSettings() {
  EEPROM.put(0, settings);
}

void loadSettings() {
  EEPROM.get(0, settings);

  if (settings.ptt_max_ms == 0xFFFFFFFFUL) {
    settings.ptt_max_ms        = 300000;
    settings.compass_period_ms = 500;
    settings.rotator_period_ms = 500;
    settings.stop_ptt_err_mask = 0x000000FF;

    settings.vbat_low_raw     = 0;
    settings.vswr1_high_raw   = 0;
    settings.vswr2_high_raw   = 0;
    settings.temp1_high_x10   = 0;
    settings.temp2_high_x10   = 0;
    settings.hum_high_pct     = 0;

    saveSettings();
  }
}

// ======================================================
// ===== CAN TX ==========================================
// ======================================================

void sendCfg(uint8_t destModule, uint8_t key, uint32_t value) {
  canTx.can_id  = RSCP_ID_CFG_SET;
  canTx.can_dlc = 8;
  memset(canTx.data, 0, 8);
  canTx.data[0] = destModule;
  canTx.data[1] = key;
  rscp_put_u32(&canTx.data[4], value);
  mcp2515.sendMessage(&canTx);
}

void pushSettingsToRemotes() {
  // Module 2 (masthead)
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_PTT_MAX_MS,        settings.ptt_max_ms);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_STOP_PTT_ERR_MASK, settings.stop_ptt_err_mask);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_VBAT_LOW_RAW,      settings.vbat_low_raw);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_VSWR1_HIGH_RAW,    settings.vswr1_high_raw);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_VSWR2_HIGH_RAW,    settings.vswr2_high_raw);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_TEMP1_HIGH_X10,    (uint32_t)(int32_t)settings.temp1_high_x10);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_TEMP2_HIGH_X10,    (uint32_t)(int32_t)settings.temp2_high_x10);
  sendCfg(RSCP_MOD_MAST, RSCP_CFG_HUM_HIGH_PCT,      settings.hum_high_pct);

  // Module 3 + 4 periods
  sendCfg(RSCP_MOD_COMPASS, RSCP_CFG_COMPASS_PERIOD_MS, settings.compass_period_ms);
  sendCfg(RSCP_MOD_ROTATOR, RSCP_CFG_ROTATOR_PERIOD_MS, settings.rotator_period_ms);

  cfgAckM2 = cfgAckM3 = cfgAckM4 = 0xFF;
}

// ======================================================
// ===== CAN RX ==========================================
// ======================================================

void processCan() {
  while (mcp2515.readMessage(&canRx) == MCP2515::ERROR_OK) {
    switch (canRx.can_id) {

      
      case RSCP_ID_PTT_STATUS: {
        // data0=state, data1=seq, data2=status_flags, data3=err_latched
        const uint8_t state = canRx.data[0];
        const uint8_t seq   = canRx.data[1];
        const uint8_t flags = canRx.data[2];
        const bool errLatched = (canRx.data[3] != 0);

        // Only accept confirmation for the most recent command sequence
        if (seq == last_cmd_seq) {
          if (state == RSCP_PTT_ON) {
            ptt_confirmed = ((flags & RSCP_PTTSTAT_CONFIRMED) != 0) && !errLatched;
          } else {
            ptt_confirmed = false;
          }
        } else {
          // If remote announces OFF for any seq, treat as OFF safety
          if (state == RSCP_PTT_OFF) ptt_confirmed = false;
        }
        break;
      }

      case RSCP_ID_ERR_STATUS: {
        // data0=module_id, data1=severity, data2..5=err_bits(uint32)
        const uint8_t mod = canRx.data[0];
        const uint8_t sev = canRx.data[1];
        const uint32_t bits = rscp_get_u32(&canRx.data[2]);

        if (mod == RSCP_MOD_MAST) {
          mast_err_bits = bits;
        }
        // Basic safety: any ERROR/FATAL from mast drops confirmed PTT
        if (mod == RSCP_MOD_MAST && (sev >= RSCP_SEV_ERROR) && bits != RSCP_ERR_NONE) {
          ptt_confirmed = false;
        }
        break;
      }

      case RSCP_ID_ENV_TELEM:
        mast.temp_x10 = rscp_get_i16(&canRx.data[0]);
        mast.humidity = canRx.data[2];
        mast.vbat_raw = rscp_get_u16(&canRx.data[3]);
        lastEnvMs = millis();
        break;

      case RSCP_ID_RF_TELEM:
        mast.vswr_state  = canRx.data[0];
        mast.drive_state = canRx.data[1];
        lastRfMs = millis();
        break;

      case RSCP_ID_HEADING:
        compass_deg = rscp_get_u16(&canRx.data[0]);
        alive_m3 = true;
        break;

      case RSCP_ID_ROT_STATUS:
        rotator_deg = rotator_deg = rscp_get_u16(&canRx.data[0]);
        alive_m4 = true;
        break;

      case RSCP_ID_CFG_ACK:
        if (canRx.data[0] == RSCP_MOD_MAST)    cfgAckM2 = canRx.data[1];
        if (canRx.data[0] == RSCP_MOD_COMPASS) cfgAckM3 = canRx.data[1];
        if (canRx.data[0] == RSCP_MOD_ROTATOR) cfgAckM4 = canRx.data[1];

        break;
    }
  }
}

// ======================================================
// ===== UI ==============================================
// ======================================================

void renderLCD() {
  const uint32_t now = millis();
  const bool rfStale = (now - lastRfMs) > 4000UL;  // no RF telem in 4s
  const bool envStale = (now - lastEnvMs) > 6000UL; // no ENV telem in 6s

  lcd.setCursor(0,0);
  lcd.print("VSWR:");
  if (rfStale || lastRfMs == 0) {
    lcd.print("N/A ");
  } else {
    lcd.print(vswrText(mast.vswr_state));
  }
  lcd.setCursor(9,0);
  lcd.print("DRV:");
  if (rfStale || lastRfMs == 0) {
    lcd.print("N/A");
  } else {
    lcd.print(driveText(mast.drive_state));
  }
lcd.setCursor(0,1);
  lcd.print("Temp:");
  if (envStale || lastEnvMs == 0) {
    lcd.print("N/A ");
  } else {
    lcd.print(mast.temp_x10 / 10.0, 1);
  }
  lcd.setCursor(9,1);
  lcd.print("V:");
  if (envStale || lastEnvMs == 0) {
    lcd.print("N/A");
  } else {
    lcd.print(vbatVoltsFromRaw(mast.vbat_raw), 1);
  }
#ifndef USE_LCD_16x2
  lcd.setCursor(0,2);
  lcd.print("Bear:");
  lcd.print(compass_deg);
  lcd.print(" Rot:");
  lcd.print(rotator_deg);

  lcd.setCursor(0,3);
  lcd.print("PTT:");
  // UI state machine (authoritative):
  // OFF  = switch not pressed
  // REQ  = switch pressed, command sent, waiting for mast
  // ON   = mast reports PTT ON and not inhibited/fail
  if (!ptt_active) {
    lcd.print("OFF");
  } else if (ptt_confirmed) {
    lcd.print("ON ");
  } else {
    lcd.print("REQ");
  }
lcd.print(" E:");
  lcd.print(mast.err_flags ? "Y " : "N ");
  lcd.print(alive_m2 ? "2" : "-");
  lcd.print(alive_m3 ? "3" : "-");
  lcd.print(alive_m4 ? "4" : "-");
#endif
}

// ======================================================
// ===== PTT =============================================
// ======================================================


// ======================================================
// ===== PTT HANDSHAKE ==================================
// ======================================================

// Local PTT state
static bool     ptt_in_active = false;    // external PTT input state (debounced minimally)
static uint8_t  ptt_seq = 0;              // increments on each command edge
static uint32_t last_ptt_cmd_ms = 0;

static inline void sendPttCmd(uint8_t onoff) {
  uint8_t d[8] = {0};
  d[0] = onoff ? RSCP_PTT_ON : RSCP_PTT_OFF;
  d[1] = ++ptt_seq;
  d[2] = 0; // flags reserved
  last_cmd_seq = ptt_seq;
  last_ptt_cmd_ms = millis();
  // Track local PTT request state (confirmation comes from RSCP_ID_PTT_STATUS)
  ptt_active = (onoff != 0);
  if (!ptt_active) ptt_confirmed = false;

  canTx.can_id  = RSCP_ID_PTT_CMD;
  canTx.can_dlc = 8;
  memcpy(canTx.data, d, 8);
  mcp2515.sendMessage(&canTx);
}

void handlePtt() {
  // External PTT input: active HIGH (external 10k pulldown, pressed=HIGH)
  // TEMP NOTE: if your wiring changes, flip this expression.
  const bool in = (digitalRead(PIN_PTT_IN) == HIGH);

  // --- minimal debounce (fast-loop friendly) ---
  static bool in_db = false;
  static bool last_raw = false;
  static uint8_t stable = 0;
  if (in == last_raw) {
    if (stable < 6) stable++;          // ~6 consecutive loops stable
  } else {
    stable = 0;
    last_raw = in;
  }
  if (stable == 6) in_db = in;

// Rising edge: request PTT
  if (in_db && !ptt_in_active) {
    sendPttCmd(1);
    ptt_in_active = true;
    // do NOT assert PIN_PTT_OUT until confirmed by remote
  }

  // Falling edge: drop PTT immediately (and clear confirmation)
  if (!in_db && ptt_in_active) {
    sendPttCmd(0);
    ptt_in_active = false;
    ptt_confirmed = false;
  }

  // If we are active but not confirmed for too long, keep output low.
  // (remote may be inhibited or offline)
  digitalWrite(PIN_PTT_LED, ptt_active);
  digitalWrite(PIN_PTT_OUT, ptt_confirmed);
}


// ======================================================
// ===== SETUP / LOOP ===================================
// ======================================================

void setup() {
  pinMode(PIN_PTT_IN, INPUT); // active-HIGH (external 10k pulldown)
  pinMode(PIN_PTT_OUT, OUTPUT);
  pinMode(PIN_PTT_LED, OUTPUT);
  pinMode(PIN_BTN, INPUT_PULLUP);

  Wire.begin();
  lcd.init();
  lcd.backlight();

  SPI.begin();
  mcp2515.reset();
  mcp2515.setBitrate(CAN_500KBPS);
  mcp2515.setNormalMode();

  loadSettings();
  lcd.clear();
}

void loop() {
  processCan();   // priority
  handlePtt();    // priority
  renderLCD();    // one lightweight task
}